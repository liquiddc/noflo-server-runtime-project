{
  "name": "noflo-test",
  "description": "NoFlo component testing library",
  "version": "0.0.7",
  "dependencies": {
    "vows": "0.7.x",
    "coffee-script": "1.6.x",
    "underscore": "1.4.x",
    "noflo": "~0.5.0"
  },
  "devDependencies": {
    "coffeelint": "*",
    "noflo-objects": "~0.1.2"
  },
  "main": "./index.js",
  "bin": {
    "noflo-test": "./bin/noflo-test"
  },
  "scripts": {
    "pretest": "./node_modules/.bin/coffeelint -r lib",
    "test": "./bin/noflo-test --spec test/*.coffee"
  },
  "readme": "NoFlo Component Tester\n=====================\n\nThis library provides a fluent, chainable API for testing [NoFlo](http://noflojs.org) components in an easy manner. It is inspired by the [api-easy](http://flatiron.github.com/api-easy) library for testing RESTful APIs.\n\nMost NoFlo components are designed to be reusable between different projects, and so having a good set of unit tests for them is vital.\n\n## Installation\n\nAdd noflo-test and [Vows](http://vowsjs.org) into your component's development dependencies:\n\n    \"devDependencies\": {\n      \"noflo-test\": \"0.0.x\",\n      \"vows\": \"*\"\n    }\n\nThen run *npm install*.\n\n## Writing tests\n\nHere is an example test file against the NoFlo core component *SplitArray*:\n\n    test = require 'noflo-test'\n\n    test.component('SplitArray').\n      discuss('When receiving an array with two cells').\n        send.data('in', ['foo', 'bar']).\n        discuss('Each cell should be sent out as a separate package').\n          receive.data('out', 'foo').\n          receive.data('out', 'bar').\n    export module\n\nIn a typical case, this is all you need to test a component!\n\n## Test API\n\nThe noflo-test library exposes one method as the entry point:\n\n**.component(ComponentName, [InstanceGetter])**\n\nThe first argument is the name of the component, which will also be the name of the generated test suite. In normal NoFlo libraries where components are registered in the package.json, this is all that is needed, as noflo-test will use NoFlo's ComponentLoader to load the component source code.\n\nIn case of custom setups you can also provide an optional second argument, which is a function that should return a new instance of a component on every invocation. Example:\n\n    test.component 'MyCustomComponent', -> new MyCustomComponent\n\n### Test suite methods\n\n**suite.discuss(description)**\n\nDescribe a scenario. NoFlo tests are usually provided in a structure where you first *discuss* the environment, then provide input arguments, then *discuss* the desirable outputs, and then provide them.\n\n#### Input commands\n\nOnce you have described a scenario using the *discuss* method, you can register a set of input commands to be sent. These will be stored into a queue and run in the order they were registered.\n\n**suite.send.connect(port)**\n\nRegister a connection event for a given input port.\n\n**suite.send.beginGroup(port, group)**\n\nRegister a new group bracket event to a given input port.\n\n**suite.send.data(port, data)**\n\nRegister data to be sent to a given input port.\n\n**suite.send.endGroup(port)**\n\nRegister an ending of group bracket to a given input port.\n\n**suite.send.disconnect(port)**\n\nRegiter a disconnection event for a given input port.\n\n#### Output commands\n\nOnce you have set up the desired inputs for a scenario, you should use *discuss* to describe the desired output. Then you can register the output events you want to see happen:\n\n**suite.receive.data(port, data)**\n\nExpect to receive matching data from the output port.\n\n#### Ending a scenario\n\n**suite.next()**\n\nEnds the current scenario so that you can start describing a new one from scratch. No data is shared between scenarios.\n\n#### Exposing your tests to Vows\n\n**suite.export(module)**\n\nExpose the tests to the Vows test runner.\n\n## Running tests\n\nThere are many test frameworks for Node.js, each with their own way of being invoked. To make your library easier to work with for newcomers, it is a good idea to provide the *npm test* command with it. Add to the package.json:\n\n    \"scripts\":    {\n      \"pretest\": \"./node_modules/.bin/coffeelint -r components\",\n      \"test\": \"./node_modules/.bin/noflo-test --spec test/*.coffee\"\n    }\n\nNow running:\n\n    $ npm test\n\nWill first check your component sources for CoffeeScript coding standards compliance, and then run all the noflo-test component tests you have in your test directory.\n\n### Travis integration\n\n[Travis CI](https://travis-ci.org/) provides a free Continuous Integration environment for open source code hosted on GitHub. If that applies to the components you're writing, it is a good idea to enable Travis for your library.\n\nTo do so, login to the Travis website, and enable it for your repository. Then add the following file to the root of your repository:\n\n    language: node_js\n    node_js:\n      - 0.6\n      - 0.8\n      - 0.10\n    script: npm test\n\nNow each time you push your project to GitHub it will be automatically tested on Travis against various different Node.js versions (tune the version numbers in the file according to your needs).\n\nPull requests made for your repository will be tested automatically as well.\n",
  "readmeFilename": "README.md",
  "_id": "noflo-test@0.0.7",
  "_from": "noflo-test@~0.0.6"
}
