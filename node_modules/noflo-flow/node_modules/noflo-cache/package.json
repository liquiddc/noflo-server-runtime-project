{
  "name": "noflo-cache",
  "description": "Packet Caching for NoFlo",
  "version": "0.0.3",
  "keywords": [
    "noflo",
    "cache"
  ],
  "author": {
    "name": "Kenneth Kan",
    "email": "kenhkan@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com:kenhkan/noflo-cache.git"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/noflo/noflo-cache/blob/master/LICENSE.md"
    }
  ],
  "dependencies": {
    "nohoarder": "~0.0.1",
    "noflo": "~0.4.0",
    "noflo-swiss": "0.0.x",
    "noflo-groups": "0.1.x",
    "noflo-adapters": "0.1.x",
    "noflo-strings": "0.1.x"
  },
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-exec": "~0.4.2",
    "noflo-test": "~0.0.4",
    "grunt-contrib-coffee": "~0.6.6",
    "grunt-coffeelint": "~0.0.6",
    "grunt-cafe-mocha": "~0.1.2",
    "chai": "~1.5.0",
    "mocha": "~1.9.0",
    "grunt-mocha-phantomjs": "~0.2.2",
    "grunt-component-build": "~0.2.7",
    "grunt-contrib-uglify": "~0.2.0",
    "grunt-contrib-watch": "~0.3.1",
    "component-json": "~0.1.4",
    "grunt-combine": "~0.8.3",
    "grunt-component": "~0.1.2"
  },
  "noflo": {
    "components": {
      "Cache": "./components/Cache.coffee"
    },
    "graphs": {
      "CacheByGroup": "./graphs/CacheByGroup.fbp",
      "Escrow": "./graphs/Escrow.fbp",
      "GroupCache": "./graphs/GroupCache.fbp",
      "WaitFor": "./graphs/WaitFor.fbp"
    }
  },
  "scripts": {
    "test": "grunt test"
  },
  "readme": "# Caching in NoFlo <br/>[![Build Status](https://secure.travis-ci.org/kenhkan/noflo-cache.png?branch=master)](http://travis-ci.org/kenhkan/noflo-cache) [![Dependency Status](https://david-dm.org/kenhkan/noflo-cache.png)](https://david-dm.org/kenhkan/noflo-cache) [![NPM version](https://badge.fury.io/js/noflo-cache.png)](http://badge.fury.io/js/noflo-cache) [![Stories in Ready](https://badge.waffle.io/kenhkan/noflo-cache.png)](http://waffle.io/kenhkan/noflo-cache)\n\nProvide caching so packets are presisted in memory for future connections. This is almost always a necessary tool when you have asynchronous operation!\n\n\n## Installation\n\n`npm install --save noflo-cache`\n\n## Usage\n\n* [cache/Cache](#Cache)\n* [cache/CacheByGroup](#CacheByGroup)\n\nListed in-ports in bold are required and out-ports in bold always produce IPs.\n\n\n### Cache\n\nSave incoming IPs and send the saved IPs to port 'out' upon any data IP from\n'ready'\n\n#### In-Ports\n\n* *IN*: The value to cache\n* *READY*: Release a particular cache by key. Release all cache if no key is\n  provided\n* KEY: The key associated with the value\n* SIZE: The maximum size\n* KEEP: Whether to keep the cached value or not after release\n\n#### Out-Ports\n\n* *OUT*: The cached value\n\n\n### CacheByGroup\n\nLike `cache/Cache`, but the to-be-cached incoming value is automatically\nassociated with the key that is the group (and the only group) to the incoming\nvalue. For instance, 'abc' would be the key in the following case:\n\n    CONNECT:\n    BEGINGROUP: 'abc'\n    DATA: 'things to cache'\n    ENDGROUP: 'abc'\n    DISCONNECT:\n\n#### In-Ports\n\n* *IN*: The value to cache. The group is used as the caching key.\n* *READY*: Release the cached value. The group of the incoming is used as the\n  the caching key.\n* SIZE: The maximum size\n* KEEP: Whether to keep the cached value or not after release\n\n#### Out-Ports\n\n* *OUT*: The cached value\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/kenhkan/noflo-cache/issues"
  },
  "homepage": "https://github.com/kenhkan/noflo-cache",
  "_id": "noflo-cache@0.0.3",
  "_from": "noflo-cache@~0.0.1"
}
