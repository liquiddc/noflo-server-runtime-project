{
  "name": "noflo-woute",
  "description": "Routing web requests based on the request's URL",
  "keywords": [
    "noflo",
    "routing",
    "web",
    "http",
    "request",
    "url"
  ],
  "author": {
    "name": "Kenneth Kan",
    "email": "kenhkan@gmail.com"
  },
  "version": "0.1.4",
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/kenhkan/noflo-woute/blob/master/LICENSE.md"
    }
  ],
  "engines": {
    "node": ">=0.6.0"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/kenhkan/noflo-woute"
  },
  "dependencies": {
    "noflo": "~0.4.0",
    "underscore": "~1.5.1",
    "noflo-webserver": "https://github.com/kenhkan/noflo-webserver/archive/0.0.3+disconnect_on_each_request.tar.gz",
    "noflo-core": "~0.1.1"
  },
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-contrib-coffee": "~0.6.6",
    "grunt-coffeelint": "~0.0.6",
    "grunt-cafe-mocha": "~0.1.2",
    "chai": "~1.5.0",
    "mocha": "~1.9.0",
    "grunt-mocha-phantomjs": "~0.2.2",
    "grunt-component-build": "~0.2.7",
    "grunt-contrib-uglify": "~0.2.0",
    "grunt-contrib-watch": "~0.3.1",
    "component-json": "~0.1.4",
    "grunt-combine": "~0.8.3",
    "grunt-component": "~0.1.2"
  },
  "noflo": {
    "components": {
      "Match": "./components/Match.coffee",
      "FromPorts": "./components/FromPorts.coffee",
      "FromGroups": "./components/FromGroups.coffee",
      "ToPorts": "./components/ToPorts.coffee",
      "ToGroups": "./components/ToGroups.coffee"
    }
  },
  "scripts": {
    "test": "grunt test"
  },
  "readme": "# Woute: A Web Request Router <br/>[![Build Status](https://secure.travis-ci.org/kenhkan/noflo-woute.png?branch=master)](https://travis-ci.org/kenhkan/noflo-woute) [![Dependency Status](https://gemnasium.com/kenhkan/noflo-woute.png)](https://gemnasium.com/kenhkan/noflo-woute) [![NPM version](https://badge.fury.io/js/noflo-woute.png)](http://badge.fury.io/js/noflo-woute) [![Stories in Ready](https://badge.waffle.io/kenhkan/noflo-woute.png)](http://waffle.io/kenhkan/noflo-woute)\n\nThe most natural way to route web requests is to use matching rules, not unlike\n[Sinatra](http://www.sinatrarb.com/) in Ruby and\n[Express](http://expressjs.com/) in JavaScript.\n\nHowever, in NoFlo, it's a network of blackboxes you connect to make a program.\nThe intuitive way is to connect incoming requests to a series of matchers;\nfailure to match forwards to the next matcher.\n\nWhen successful matches occur, the request is sent to wherever the programmer\nwants, which hopefully produces some result to be sent to a responder. An\nabstract example would be:\n\n    \n                           /login                /get_images\n                             +                      +\n                             |                      |\n                             |                      |\n    +-----------+        +---v-------+         +----v------+           +------------+\n    |           |        |           |         |           |           |            |\n    |           |  Req   |  First    |  Fail   |  Second   |  Fail     |  Third     |\n    | Webserver +-------->  Matcher  +--------->  Matcher  +----------->  Matcher   |\n    |           |        |           |         |           |           |            |\n    +-----------+        +---+-------+         +----+------+           +---+--------+\n                             |                      |                      |\n                             |Success               |Success               |Success\n                             |                      |                      |\n                         +---v-------+         +----v------+           +---v--------+\n                         |           |         |           |           |            |\n                         |           |         |           |           |            |\n                         |           |         | Fetch     |           |            |\n                         | Login     |         | Images    |           | 404        |\n                         |           |         |           |           |            |\n                         +-----+-----+         +----+------+           +---+--------+\n                               |                    |                      |\n                               |                    |Res                   |\n                               |Res                 |                      |Res\n                               |               +----v------+               |\n                               |               |           |               |\n                               +--------------->           <---------------+\n                                               | Respond   |\n                                               |           |\n                                               +-----------+\n\n\n## Installation\n\n    npm install --save noflo-woute\n\n\n## Quick & Dirty Usage\n\nTo use noflo-woute in its most basic form, you only need the `Matcher`\ncomponent:\n\n* Inport `MATCH`: *optional* takes a URL segment to match. Default to always\n  match\n* Inport `METHOD`: *optional* an HTTP method. Default to any method\n* Inport `IN`: takes a request/response pair produced by\n  [noflo-webserver](https://github.com/noflo/noflo-webserver)\n* Outport `OUT`: the request/repsonse pair if match is successful\n* Outport `FAIL`: the request/response pair if match is unsuccessful, most\n  likely attached to another matcher\n\nSimply connect some matchers together like the abstract example shown above and\nyou're good to go!\n\n\n## More Advanced Usage: Adapters\n\nMatchers are agnostic to the actual request/response, meaning that whoever\nhandling a successfully matched case is handed the same thing that they would\nget from noflo-webserver. Two pairs of adapter components are there to help you\nto \"split\" the request into different parts so manipulation is easier:\n`woute/ToGroups`, `woute/ToPorts`, and their other halves `woute/FromGroups`\nand `woute/FromPorts`.\n\nBoth adapter pairs break the request/response object into these parts:\n\n* `url`: ditto\n* `headers`: the HTTP headers broken down into pairs (as an object of headers)\n* `query`: the query string broken down into pairs (as an object of queries)\n* `body`: the body passed through as-is (i.e. always a string)\n* `request`: the request/response object\n\n`ToGroups` converts the incoming request/response object into the listed parts\ngrouped by the names. Groups are constructed and sent in the order of the list\nabove. `ToPorts` converts the object into the parts via ports by those names.\n\nFor instance, out comes from port `ToGroups` within a single connection:\n\n    BEGINGROUP: URL\n    DATA: /login\n    ENDGROUP: URL\n    BEGINGROUP: HEADERS\n    DATA: { \"x-http-destination\": \"NoFlo Awesomeness\" }\n    ENDGROUP: HEADERS\n    BEGINGROUP: QUERY\n    DATA: { this: \"is sent\", as: \"an object\" }\n    ENDGROUP: QUERY\n    BEGINGROUP: BODY\n    DATA: {\"this\":[{\"is\":\"JSON\",\"but\":\"is\"},{\"still\":\"sent\"}],\"as\":\"a string\"}\n    ENDGROUP: BODY\n    BEGINGROUP: REQUEST\n    DATA: <The request/response object>\n    ENDGROUP: REQUEST\n\nFor `ToPorts`, the same data packets would be sent to ports `URL`, `HEADERS`,\n`QUERY`, `BODY`, and `REQUEST`, respectively. Both `ToGroups` and `ToPorts`\nretain all the groups emitted from noflo-webserver.\n\n### Preparing for response\n\nWhen you are done and are ready to send back a response, remember to feed your\ncontent to these two components' significant others: `woute/FromGroups` and\n`woute/FromPorts`. These two components take the disassembled data packets,\napply them on a response object, and splice the connection back into\nrequest/repsonse pair so it's ready to be sent to\n[webserver/SendResponse](https://github.com/noflo/noflo-webserver/blob/master/components/SendResponse.coffee).\n\nThe components take these types of data packets:\n\n* `status`: the status code to set\n* `headers`: the response headers to be sent back\n* `body`: the body to be sent back\n* `request`: the request/response object\n\n### Which way is best?\n\n`ToPorts` makes the HTTP request much more manageable as it breaks down the\nmain parts of an HTTP request into separate connections. However, there is a\ndown side: you need to be careful when asynchronous operation is involved.\n\nAsynchronous operation removes a connection on a port from another, rendering\n`FromPorts` unable to splice them back into a request/response object. Yes,\nnoflo-webserver does wrap the request around with a unique UUID for\nidentification of a single HTTP request, but noflo-woute ignores that (but\nstill retains it as a group). It is the responsibility of the programmer or a\ndifferent package built on top of noflo-woute to handle asynchronicity.\n\nAlso, `ToPorts` triggers the re-assembly of the request/response object as soon\nas it receives a request/response object because it would otherwise not know\nwhen to apply the content of the packets on the response object. This means\nthat anything that is sent after the request/response object is received is\nignored.\n\n`ToGroups` on the other hand puts everything within the same connection so\nthere isn't any synchronicity problem as you pass the entire object around all\nat once. However, every time you need to find what you want and manipulate it,\nyou need to weed through all the groups. Both approaches have pros and cons,\nhence the options.\n\n\n## Gotchas\n\n* In order for noflo-woute to recognize the `BODY` part, you need to run the\n  request through\n  [webserver/BodyParser](https://github.com/noflo/noflo-webserver/blob/master/components/BodyParser.coffee)\n* `FromPorts` and `FromGroups` both expect the incoming body to be a string.\n  You must JSONify or perform any conversion before feeding the body to the two\n  components.\n* Remember to apply any desired\n  [middleware](https://github.com/noflo/noflo-webserver/tree/master/components)\n  before passing the request/response object to any matcher.\n\n\n## Examples\n\n### Echo Server\n\nRun the server:\n\n    > cd examples/echo_server\n    > npm install\n    > npm run-script main\n\nGet back exactly what you pass in:\n\n    > curl \"http://localhost:1337/echo\" -d '{\"a\":\"b\"}' -H \"Content-Type: application/json\"\n    {\"a\":\"b\"}\n\nGet back the string 'empty-body':\n\n    > curl \"http://localhost:1337/empty-body\" -d '{\"a\":\"b\"}' -H \"Content-Type: application/json\"\n    empty-body\n\nPrint to console of incoming body, but get nothing in return:\n\n    > curl \"http://localhost:1337/anything-here\" -X POST -d '{\"a\":\"b\"}' -H \"Content-Type: application/json\"\n\nFile not found:\n\n    > curl \"http://localhost:1337/abc\" -I\n    HTTP/1.1 404 Not Found\n    Date: Sat, 10 Aug 2013 08:35:04 GMT\n    Connection: keep-alive\n\nTo look at how these work, read the [FBP code](https://github.com/kenhkan/noflo-woute/blob/master/examples/echo_server/graphs/main.fbp).\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/kenhkan/noflo-woute/issues"
  },
  "homepage": "https://github.com/kenhkan/noflo-woute",
  "_id": "noflo-woute@0.1.4",
  "_from": "noflo-woute@*"
}
